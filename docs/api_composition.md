---
id: api_composition
title: RocketJump Composition
sidebar_label: Composition
---
RocketJumps can be merged!

As stated in the initial part of the API description, the `rj` constructor can take several arguments, each of which can be the result of a previous call (provided that the `effect` property was not set), a provided plugin, or a configuration object. Calling `rj` with several arguments is interpreted as a composition will.

```js
const rj1 = rj({ /* config 1 */ })

const rj2 = rj({ /* config 2 */ })

const __GENERATED__ = rj(
  rj1,
  rj2,
  {/* last config */ },
)
```

## How does composition work?
Consider the following example

```js
const rj0 = rj({ /* config R */ });
const rj1 = rj(rj0, { /* config O */ });
const rj2 = rj({ /* config C */ });
const final = rj(rj1, rj2, { /* config K */ });
```

The composition order goes from top to bottom and from left to right. Hence, in our example, we have the following composition order: `config R > config O > config C > config K`.

First of all, predefined actions, selectors and reducer are generated. Then the composition tree is traversed:
- `actions` and `selectors` are evaluated in composition order, and the result is recursively merged: the `actions` attribute of configO can use the actions generated by the property `actions` in configR, and so on. The same holds for selectors.
- `reducer` attributes are applied recursively in composition order. In our example the final reducer will be the output of `reducerK(reducerC(reducerO(reducerR(defaultReducer))))`
- `effectCaller` and `takeEffect` attributes are not merged, and only the latest in the composition tree is applied. Composition order is, as usual, increasing from top to bottom and from left to right. In our example, the order of precedence would be `config K > config C > config O > config R`.