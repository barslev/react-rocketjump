(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{113:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return s}));var a=n(3),r=(n(0),n(133));const o={id:"consume_rj_objects",title:"Consume RjObjects",sidebar_label:"Consume RjObjects",slug:"/consume-rj-objects"},i={unversionedId:"consume_rj_objects",id:"consume_rj_objects",isDocsHomePage:!1,title:"Consume RjObjects",description:"Action creators Builder",source:"@site/docs/consume_rj_objects.md",slug:"/consume-rj-objects",permalink:"/react-rocketjump/docs/next/consume-rj-objects",editUrl:"https://github.com/inmagik/react-rocketjump/edit/master/website/docs/consume_rj_objects.md",version:"current",sidebar_label:"Consume RjObjects",sidebar:"someSidebar",previous:{title:"Mutations",permalink:"/react-rocketjump/docs/next/mutations"},next:{title:"Plugin System",permalink:"/react-rocketjump/docs/next/plugin-system"}},c=[{value:"Action creators Builder",id:"action-creators-builder",children:[{value:"withMeta(function)",id:"withmetafunction",children:[]},{value:"withMeta(object)",id:"withmetaobject",children:[]},{value:"onSuccess",id:"onsuccess",children:[]},{value:"onFailure",id:"onfailure",children:[]},{value:"curry",id:"curry",children:[]},{value:"run",id:"run",children:[]},{value:"asPromise",id:"aspromise",children:[]}]},{value:"useRj",id:"userj",children:[]},{value:"connectRj",id:"connectrj",children:[{value:"The compose helper",id:"the-compose-helper",children:[]}]},{value:"useRunRj",id:"userunrj",children:[{value:"Basic usage",id:"basic-usage",children:[]},{value:"Automatic dependency management",id:"automatic-dependency-management",children:[]},{value:"deps.maybe",id:"depsmaybe",children:[]},{value:"deps.maybeNull",id:"depsmaybenull",children:[]},{value:"deps.maybeGet",id:"depsmaybeget",children:[]},{value:"deps.allMaybe",id:"depsallmaybe",children:[]},{value:"deps.allMaybeNull",id:"depsallmaybenull",children:[]},{value:"deps.withMeta",id:"depswithmeta",children:[]},{value:"deps.withAlwaysMeta",id:"depswithalwaysmeta",children:[]},{value:"deps.withMetaOnMount",id:"depswithmetaonmount",children:[]},{value:"Multiple meta setting markers in deps",id:"multiple-meta-setting-markers-in-deps",children:[]}]}],l={toc:c};function s({components:e,...t}){return Object(r.b)("wrapper",Object(a.a)({},l,t,{components:e,mdxType:"MDXLayout"}),Object(r.b)("h2",{id:"action-creators-builder"},"Action creators Builder"),Object(r.b)("p",null,"When you consume an RjObject its action creators are bound\nto current state and side effects instance.\nPlus a special builder were attached.\nYou can still inoke them as simply functions."),Object(r.b)("p",null,"The methods exposed on bound action creators by the builder are:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"Builder builder = actionCreator.withMeta(object)\nBuilder builder = actionCreator.withMeta(oldMeta => newMeta)\nBuilder builder = actionCreator.onSuccess(callback)\nBuilder builder = actionCreator.onError(callback)\nBuilder builder = actionCreator.asPromise(...args)\n")),Object(r.b)("p",null,"Each of these methods instantiates a new Builder to be used for the ",Object(r.b)("em",{parentName:"p"},"rich")," call, and calls the omonimous method on the created builder (so avoiding an explicit call to instantiate the builder)."),Object(r.b)("p",null,"The methods exposed by the builder object are:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"builder.withMeta(object)\nbuilder.withMeta((oldMeta) => newMeta)\nbuilder.onSuccess(callback)\nbuilder.onError(callback)\nbuilder.run(...args)\nbuilder.asPromise(...args)\n")),Object(r.b)("p",null,"First of all, builder methods are designed to be chainable, hence probably you'll never create a ",Object(r.b)("inlineCode",{parentName:"p"},"builder")," variable in your code, but you'd end up writing something like"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"run\n  .withMeta({ id: 42 })\n  .onSuccess((data) => console.log(data))\n  .onError((err) => console.warn(err))\n  .run()\n")),Object(r.b)("p",null,"Now, let's go describing the methods of the builder."),Object(r.b)("h3",{id:"withmetafunction"},"withMeta(function)"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.withMeta(oldMeta => newMeta)")),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"withMeta")," builder method allows to add a transform on metadata attached to the action. The transform is encoded as a function that receives the old metadata object (a JavaScript plain object) and is required to return the next metadata object (again, as a plain JavaScript object). This method can be used to add some metadata, to change some of them, or even to delete some keys (even if you should do it with care). Calling ",Object(r.b)("inlineCode",{parentName:"p"},"withMeta")," multiple times simply chains all the transformation, such that the output of the first is the input of the second and so on, the metadata object attached to the action will be the output of the last transform."),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("p",null,"This call exposes the ",Object(r.b)("inlineCode",{parentName:"p"},"key")," meta data under the ",Object(r.b)("inlineCode",{parentName:"p"},"id")," property"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"builder.withMeta(prevMeta => { ...prevMeta, id: prevMeta.key })\n")),Object(r.b)("h3",{id:"withmetaobject"},"withMeta(object)"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.withMeta(object)")),Object(r.b)("p",null,"This is equivalent to ",Object(r.b)("inlineCode",{parentName:"p"},"builder.withMeta(prevMeta => { ...prevMeta, ...object })"),", it can be useful as a quick and lightweight way to add some keys to the metadata object"),Object(r.b)("h3",{id:"onsuccess"},"onSuccess"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.onSuccess(callback)")),Object(r.b)("p",null,"This method allows to attach a callback to be invoked when the asynchronous task completes without errors. The callback is not invoked in case the task it is attached to is canceled (see ",Object(r.b)("a",{parentName:"p",href:"/react-rocketjump/docs/next/side-effects"},"takeEffect"),"). Calling this method multiple times on the same builder causes the callback to be overwritten: the callback attached to the action is the argument of the last invocation of this method"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("p",null,"Triggering an alert when an action completes"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"builder.onSuccess((data) => alert(data[0].name))\n")),Object(r.b)("h3",{id:"onfailure"},"onFailure"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.onFailure(callback)")),Object(r.b)("p",null,"This method allows to attach a callback to be invoked when the asynchronous task completes with errors. The callback is not invoked in case the task it is attached to is canceled (remember ",Object(r.b)("a",{parentName:"p",href:"/react-rocketjump/docs/next/side-effects"},"takeEffect"),"). Calling this method multiple times on the same builder causes the callback to be overwritten: the callback attached to the action to handle failures is the argument of the last invocation of this method"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("p",null,"Triggering an alert when an action completes"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"builder.onFailure((data) => alert(data[0].name))\n")),Object(r.b)("h3",{id:"curry"},"curry"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.curry(...args)")),Object(r.b)("p",null,"This method return a ",Object(r.b)("strong",{parentName:"p"},"new builder instance")," with ",Object(r.b)("inlineCode",{parentName:"p"},"args")," curried.\nThe previous ",Object(r.b)("inlineCode",{parentName:"p"},"onSuccess"),", ",Object(r.b)("inlineCode",{parentName:"p"},"onFailure")," and ",Object(r.b)("inlineCode",{parentName:"p"},"withMeta")," are also copied to the\nnew builder instance."),Object(r.b)("p",null,"Cause the curry method return a new instance of builder is prefered to wrap it\nin ",Object(r.b)("inlineCode",{parentName:"p"},"React.useMemo"),"."),Object(r.b)("p",null,"The curry pattern can be useful if you need to pass to a child component\na callback with the capabilities of builder with wrapped logic:"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"const ProductState = rj({\n  mutations: {\n    updateProduct: {\n      effect: (catgory, updateData) => updateProductApi(catgory, updateData),\n      updater: 'updateData',\n    },\n  },\n  // ...\n})\n\nfunction ProductForm({ product, onProductUpdate }) {\n  // NOTE: This is for example purpose only in real word\n  // you may use library such Formik\n  const [formState, setFormState] = useState(product)\n  return (\n    <form\n      onSubmit={() => {\n        onProductUpdate\n          .onSuccess(() => {\n            // ... do form stuff\n          })\n          // NOTE: the category is curried so we need to pass only\n          // the second effect argument!\n          .run(formState)\n      }}\n    >\n      {/* ... */}\n    </form>\n  )\n}\n\nfunction EditProduct({ category }) {\n  const [{ product }, { updateProduct }] = useRunRj(ProductState, [category])\n\n  const onProductUpdate = useMemo(\n    () =>\n      updateProduct\n        .onSuccess(() => {\n          // ... do stuff\n        })\n        .curry(category),\n    [updateProduct, category]\n  )\n\n  return (\n    <>\n      <ProductForm product={product} onProductUpdate={onProductUpdate} />\n    </>\n  )\n}\n")),Object(r.b)("h3",{id:"run"},"run"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.run(...args)")),Object(r.b)("p",null,"This method closes the builder and dispatches the action with the passed in ",Object(r.b)("inlineCode",{parentName:"p"},"...args")," as params and the configuration defined with the other methods. This method must be the last invocation on a builder, no further configuration will be taken into account after calling it."),Object(r.b)("h3",{id:"aspromise"},"asPromise"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"builder.asPromise(...args)")),Object(r.b)("p",null,"This method closes the builder and dispatches the action with the passed in ",Object(r.b)("inlineCode",{parentName:"p"},"...args")," as params and the configuration defined with the other methods. This method must be the last invocation on a builder, no further configuration will be taken into account after calling it. The return value of this method is no more a ",Object(r.b)("inlineCode",{parentName:"p"},"Builder")," instance, but a ",Object(r.b)("inlineCode",{parentName:"p"},"Promise"),"."),Object(r.b)("p",null,"If you set callbacks with ",Object(r.b)("inlineCode",{parentName:"p"},"builder.onSuccess")," or ",Object(r.b)("inlineCode",{parentName:"p"},"builder.onFailure"),", they will be invoked properly before the Promise completes (either resolving or rejecting)"),Object(r.b)("p",null,Object(r.b)("strong",{parentName:"p"},"Example")),Object(r.b)("p",null,"Returning a Promise from an action"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"builder\n  .asPromise(1, 'admin')\n  .then(() => {\n    console.log('success')\n  })\n  .catch(() => {\n    console.log('failure')\n  })\n")),Object(r.b)("h2",{id:"userj"},"useRj"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"useRj")," is a React Hook that allows the instantiation of one RjObject\nwhich is then made available to the component.",Object(r.b)("br",null),"\nIt accept an RjObject as input and return its ",Object(r.b)("a",{parentName:"p",href:"/react-rocketjump/docs/next/computed-state-and-selectors"},"computed state"),"\nand ",Object(r.b)("a",{parentName:"p",href:"/react-rocketjump/docs/next/action-creators"},"action creators"),"."),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { rj, useRj } from 'react-rocketjump'\n\nconst TodosState = rj(() => fetch('/api/todos').then((r) => r.json()))\n\nfunction Todos() {\n  const [{ data, pending, error }, { run }] = useRj(TodosState)\n  // ...\n}\n")),Object(r.b)("p",null,"useRj acept a second optional parameter ",Object(r.b)("inlineCode",{parentName:"p"},"selectState"),":"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"(internalState, selectors, computedState) => outState\n")),Object(r.b)("p",null,"You can use it to map the returned state using selectors:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { useRj } from 'react-rocketjump'\n\nconst Component = (props) => {\n  const [{ gooData }, { run }] = useRj(rjObject, (state, { getData }) => ({\n    goodData: getData(state),\n  }))\n  // ...\n}\n")),Object(r.b)("h2",{id:"connectrj"},"connectRj"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"connectRj")," function give you the exact contract of ",Object(r.b)("inlineCode",{parentName:"p"},"useRj")," but in form of\nhigher-order component (HOC).",Object(r.b)("br",null),"\nIt accept an RjObject and give you the ",Object(r.b)("strong",{parentName:"p"},"computed state")," and ",Object(r.b)("strong",{parentName:"p"},"action creators"),"\nas props:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { rj, connectRj } from 'react-rocketjump'\n\nconst TodosState = rj(() => fetch('/api/todos').then((r) => r.json()))\n\nfunction Todos({\n  // computed state props\n  data,\n  pending,\n  error,\n  // action creators props\n  run,\n  clean,\n  cancel,\n}) {\n  // ...\n}\n\nexport default connectRj(TodosState)(Todos)\n")),Object(r.b)("p",null,"You can change the mapping between your RjObject and your React Component using\ntwo optional paramters provided by connectRj. ",Object(r.b)("br",null),"\nThe ",Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps")," argument:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"(internalState, memoizedSelectors, props, computedState) => outStateProps\n")),Object(r.b)("p",null,"And the ",Object(r.b)("inlineCode",{parentName:"p"},"mapActionsToProps")," argument:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"(actionCreators) => outActionsProps\n")),Object(r.b)("p",null,"Let's an example:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"function Todos({\n  // computed state props\n  todos,\n  loadingTodos,\n  errorOnTodos,\n  // action creators props\n  fetchTodos,\n}) {\n  // ...\n}\n\nfunction mapStateToProps(\n  internalState,\n  memoizedSelectors,\n  props,\n  computedState\n) {\n  return {\n    todos: memoizedSelectors.getData(internalState),\n    loadingTodos: memoizedSelectors.isPending(internalState),\n    errorOnTodos: memoizedSelectors.getError(internalState),\n  }\n}\n\nfunction mapActionsToProps(actionCreators) {\n  return {\n    fetchTodos: actionCretors.run,\n  }\n}\n\nexport default connectRj(TodosState, mapStateToProps, mapActionsToProps)(Todos)\n")),Object(r.b)("h3",{id:"the-compose-helper"},"The compose helper"),Object(r.b)("p",null,"Finally RocketJump provide you a functional helper to compose togheter multiple\n",Object(r.b)("inlineCode",{parentName:"p"},"connectRj")," instance."),Object(r.b)("p",null,"Instead of writing this:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { connectRj } from 'react-rocketjump'\n\nconst ConnectedComponent = connectRj(\n  rjObjectA,\n  mapStateAToProps,\n  mapActionsAToProps\n)(connectRj(rjObjectB, mapStateBToProps, mapActionsBToProps)(Component))\n")),Object(r.b)("p",null,"You can use the ",Object(r.b)("inlineCode",{parentName:"p"},"compose")," helper and write:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { connectRj, compose } from 'react-rocketjump'\n\nconst ConnectedComponent = compose(\n  connectRj(rjObjectA, mapStateAToProps, mapActionsAToProps),\n  connectRj(rjObjectB, mapStateBToProps, mapActionsBToProps)\n)(Component)\n")),Object(r.b)("h2",{id:"userunrj"},"useRunRj"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"useRunRj")," hook, just like ",Object(r.b)("inlineCode",{parentName:"p"},"useRj"),", allows to instantiate a RjObject in the definition of a React Component. Unlike ",Object(r.b)("inlineCode",{parentName:"p"},"useRj"),", this hook automatically schedules the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call of the RjObject when there is a change in its arguments. To stress the concept that the control point of the effect are its arguments, we will also refer to them as ",Object(r.b)("em",{parentName:"p"},"dependencies"),", but this is only a different point of view: the ",Object(r.b)("em",{parentName:"p"},"dependencies")," argument of the ",Object(r.b)("inlineCode",{parentName:"p"},"useRunRj")," hook is used to understand when the effect should be run, and the items of the ",Object(r.b)("em",{parentName:"p"},"dependencies")," array is spread as arguments on the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call."),Object(r.b)("h3",{id:"basic-usage"},"Basic usage"),Object(r.b)("p",null,"The signature of the hook is:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"useRunRj(\n  RjObject,\n  deps = [],\n  shouldCleanBeforeRun = true,\n  mapStateToProps = (state) => state)\n) : [state, actions]\n")),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"rjObject"),": an ",Object(r.b)("a",{parentName:"p",href:"/react-rocketjump/docs/next/rj-object"},"RjObject"),"."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"deps")," is the ",Object(r.b)("em",{parentName:"p"},"dependencies")," array. You can pass any JavaScript array with any content (provided you can deal with it in the implementation of the ",Object(r.b)("inlineCode",{parentName:"p"},"effect")," property of the ",Object(r.b)("inlineCode",{parentName:"p"},"rjObject")," argument), or you can decide to opt-in for ",Object(r.b)("em",{parentName:"p"},"automatic dependency management")," (see later). Either way, the items you put in this array will be the arguments with which your effect will be invoked."),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"shouldCleanBeforeRun"),", if set to ",Object(r.b)("inlineCode",{parentName:"p"},"true"),", instructs the hook to run the ",Object(r.b)("inlineCode",{parentName:"p"},"clean")," action before triggering ",Object(r.b)("inlineCode",{parentName:"p"},"run")," (except for the first run, when no clean is triggered)"),Object(r.b)("p",null,Object(r.b)("inlineCode",{parentName:"p"},"mapStateToProps")," is a function that is used to modify the shape of the state before returning it to the component.\nWorks as explained in ",Object(r.b)("inlineCode",{parentName:"p"},"useRj")," section."),Object(r.b)("p",null,"This is a very simple example of how this hook is expected to be used:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-jsx"},"import { rj, useRunRj } from 'react-rocketjump'\n\nconst UserState = rj({\n  effect: (userId, group) =>\n    fetch(`/api/user/${userId}?group=${group}`).then((r) => r.json()),\n  computed: {\n    user: 'getData',\n  },\n})\n\nfunction UserCard({ userId, group }) {\n  const [{ user }] = useRunRj(UserState, [userId, group], false)\n  return <h1>Hello {user?.name}</hi>\n}\n")),Object(r.b)("p",null,"Dependencies should be defined with care to avoid unnecessary ",Object(r.b)("inlineCode",{parentName:"p"},"run")," calls. The following example shows how you can blow your work up with a simple distraction"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js",metastring:"{7}","{7}":!0},"import { useRunRj } from 'react-rocketjump'\nimport MyResourceRj from './localstate'\n\nfunction Component() {\n  const [{ data: resource }, actions] = useRunRj(\n    MyResourceRj,\n    // DON'T DO THIS\n    [{ params: props.resourceName }],\n    false\n  )\n}\n")),Object(r.b)("p",null,"In this example, the first (and only) item of the ",Object(r.b)("em",{parentName:"p"},"dependencies")," array is a plain object. While this is not an issue for ",Object(r.b)("em",{parentName:"p"},"rocketjump")," itself, it causes an infinite loop of calls. This comes from the fact that, at each render, a new ",Object(r.b)("inlineCode",{parentName:"p"},"Object")," instance is created from that definitions, and hence, when ",Object(r.b)("em",{parentName:"p"},"rocketjump")," checks if ",Object(r.b)("em",{parentName:"p"},"dependencies")," array changed, if finds a different object with respect to the previous render call, and so it triggers a new ",Object(r.b)("inlineCode",{parentName:"p"},"run"),". When this run completes, the component is re-rendered with the ",Object(r.b)("inlineCode",{parentName:"p"},"resource")," const set to the results, but in rerendering the object passed as a dependency changes again, hance the loop."),Object(r.b)("p",null,"The proper way to achive the same behaviour without blowing up the application is to rely on memoization to ensure that ",Object(r.b)("em",{parentName:"p"},"dependencies")," array contains referentially stable items"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { useMemo } from 'react'\nimport { useRunRj } from 'react-rocketjump'\nimport MyResourceRj from './localstate'\n\nfunction Component(props) {\n  const filter = useMemo(\n    () => ({\n      params: props.resourceName,\n    }),\n    [props.resourceName]\n  )\n\n  const [{ data: resource }, actions] = useRunRj(MyResourceRj, [filter], false)\n}\n")),Object(r.b)("h3",{id:"automatic-dependency-management"},"Automatic dependency management"),Object(r.b)("p",null,"When using multiple RjObjects in the same component, it may happen that the dependency array of a ",Object(r.b)("inlineCode",{parentName:"p"},"useRunRj")," hook depends on the response of the invocation of another ",Object(r.b)("inlineCode",{parentName:"p"},"useRunRj"),". This is only a particular case of a more complex problem: how can we deal with potentially missing dependencies? Since hooks cannot be called conditionally, the only way to trigger a ",Object(r.b)("inlineCode",{parentName:"p"},"run")," action on some RjObject only when its dependencies are available is to manually write a conditional call inside a custom ",Object(r.b)("inlineCode",{parentName:"p"},"useEffect"),". Starting with ",Object(r.b)("inlineCode",{parentName:"p"},"react-rocketjump")," version ",Object(r.b)("strong",{parentName:"p"},"2.1.0"),", dependency management can be solved in a declarative way by marking dependencies that must be awaited before a run is triggered. Note that the concept of awaiting is general: you may want to await that an API call completes as well as that the user fills out a box and hits ",Object(r.b)("inlineCode",{parentName:"p"},"Enter"),"."),Object(r.b)("p",null,"RocketJump provides various tools to deal with (potentially) missing dependencies, which can be imported as"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { deps } from 'react-rocketjump'\n")),Object(r.b)("p",null,"Each tool can be interpreted as a marker, which instructs the rocketjump engine whether to trigger a ",Object(r.b)("inlineCode",{parentName:"p"},"run")," or not, and eventually to attach some metadata to it. There are two main classes of markers: ",Object(r.b)("em",{parentName:"p"},"run preventing markers")," and ",Object(r.b)("em",{parentName:"p"},"meta setting markers")),Object(r.b)("h3",{id:"depsmaybe"},"deps.maybe"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"run preventing marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.maybe(value): Dep\n")),Object(r.b)("p",null,"The ",Object(r.b)("em",{parentName:"p"},"maybe")," marker is the most simple marker you can think of: it tells the engine not to run the effect as long as the ",Object(r.b)("inlineCode",{parentName:"p"},"value")," argument is falsy, and to run it inserting ",Object(r.b)("inlineCode",{parentName:"p"},"value")," as a positional argument otherwise"),Object(r.b)("p",null,"The ",Object(r.b)("inlineCode",{parentName:"p"},"Dep")," instance returned by the marker exposes a ",Object(r.b)("em",{parentName:"p"},"withMeta")," method, that allows to set some metadata to be attached to the next ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call in case ",Object(r.b)("inlineCode",{parentName:"p"},"value")," has changed from the last ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call (metadata are always attached to the first call, since there is no previous value to compare)."),Object(r.b)("p",null,"For example, you can do something like this"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"import { useRunRj, deps } from 'react-rocketjump'\nimport MyResourceRj from './localstate'\n\nconst Component = (props) => {\n  const [{ data: resource }, actions] = useRunRj(\n    MyResourceRj,\n    [deps.maybe(props.resourceId).withMeta({ changedResourceId: true })],\n    false\n  )\n}\n")),Object(r.b)("p",null,Object(r.b)("em",{parentName:"p"},"value")," can belong to any JS type or it can be the output of a ",Object(r.b)("em",{parentName:"p"},"withMeta")," marker. Using any other markers result in undefined behaviour.\nNote that the following statements are fully equivalent:"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"/* #1 */ deps.maybe(arg).withMeta(meta)\n/* #2 */ deps.maybe(deps.withMeta(arg, meta))\n")),Object(r.b)("p",null,"Note that you can chain ",Object(r.b)("inlineCode",{parentName:"p"},".withMeta()")," invocations on the output of a marker. In this case, the final ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," object will be the shallow merging of the ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," objects in call order (i.e. the later the call the higher the priority)"),Object(r.b)("h3",{id:"depsmaybenull"},"deps.maybeNull"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"run preventing marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.maybeNull(value): Dep\n")),Object(r.b)("p",null,"This marker is very similar to ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),", but prevents a ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call only in case the ",Object(r.b)("inlineCode",{parentName:"p"},"value")," argument is ",Object(r.b)("inlineCode",{parentName:"p"},"null"),", and not any falsy value like the ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),". So, please refer to the docs about ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe")," keeping this difference in mind."),Object(r.b)("h3",{id:"depsmaybeget"},"deps.maybeGet"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"run preventing marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.maybeGet(value, path): Dep\n")),Object(r.b)("p",null,"This marker is very similar to ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),", but instead of injecting ",Object(r.b)("inlineCode",{parentName:"p"},"value")," as an argument to the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call, it injects ",Object(r.b)("inlineCode",{parentName:"p"},"lodash.get(value, path)"),". So, please refer to the docs about ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe")," keeping this difference in mind"),Object(r.b)("h3",{id:"depsallmaybe"},"deps.allMaybe"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"run preventing marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.allMaybe([value1, value2, ..., valueN]): Dep[]\n")),Object(r.b)("p",null,"This marker is a shortcut to apply the ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe")," marker to several elements organized in an array. Hence, ",Object(r.b)("inlineCode",{parentName:"p"},"valueX")," elements can be anything that can be passed as ",Object(r.b)("inlineCode",{parentName:"p"},"value")," to ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),". Please, carefully read docs about ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe")," before using this"),Object(r.b)("h3",{id:"depsallmaybenull"},"deps.allMaybeNull"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"run preventing maker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.allMaybeNull([value1, value2, ..., valueN]): Dep[]\n")),Object(r.b)("p",null,"This marker is a shortcut to apply the ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybeNull")," marker to several elements organized in an array. Hence, ",Object(r.b)("inlineCode",{parentName:"p"},"valueX")," elements can be anything that can be passed as ",Object(r.b)("inlineCode",{parentName:"p"},"value")," to ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),". Please, carefully read docs about ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe")," and ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybeNull")," before using this"),Object(r.b)("h3",{id:"depswithmeta"},"deps.withMeta"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"meta setting marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.withMeta(value, meta): Dep\n")),Object(r.b)("p",null,"This marker allows to set some metadata on the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call whenever ",Object(r.b)("inlineCode",{parentName:"p"},"value")," changes (with respect to the previous render call). ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," must be a plain JavaScript object, while value can be either any JavaScript value, or the output of a ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybe"),", ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybeNull"),", ",Object(r.b)("inlineCode",{parentName:"p"},"deps.maybeGet")," or ",Object(r.b)("inlineCode",{parentName:"p"},"deps.withMeta")," invocation. For the first three situations, refer to the documentation of the appropriate marker."),Object(r.b)("p",null,"This marker cannot be used to prevent the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," trigger, but its ",Object(r.b)("inlineCode",{parentName:"p"},"value")," argument is still injected as a positional argument into the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call"),Object(r.b)("p",null,"Nesting ",Object(r.b)("inlineCode",{parentName:"p"},"deps.withMeta")," markers results in ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," objects being merged from inside to outside: this means that, in case of name clashes in properties, the winning value will be the outermost one."),Object(r.b)("p",null,"As for any other ",Object(r.b)("inlineCode",{parentName:"p"},"Dep"),"-returning marker, you can call ",Object(r.b)("inlineCode",{parentName:"p"},".withMeta(other_meta)")," on the output of the marker, and you can also chain multiple calls. As usual in ",Object(r.b)("em",{parentName:"p"},"rocketjump"),", ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," objects will be merged from left to right."),Object(r.b)("p",null,"To clarify the composition rules, observe the following example. Despite being pretty cumbersome, it should cover any possible case of priority"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps\n  .withMeta(deps.withMeta(deps.withMeta(value, metaC), metaB), metaA)\n  .withMeta(metaD)\n  .withMeta(metaE)\n\n// Final meta object will be (hope you like spread operators)\nconst finalMeta = {\n  ...{\n    ...{\n      ...{\n        ...metaC,\n        ...metaB,\n      },\n      ...metaA,\n    },\n    ...metaD,\n  },\n  ...metaE,\n}\n")),Object(r.b)("h3",{id:"depswithalwaysmeta"},"deps.withAlwaysMeta"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"meta setting marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.withAlwaysMeta(meta): Dep\n")),Object(r.b)("p",null,"This marker allows to set metadata on a ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call unconditionally. The ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," argument must be a plain javascript object. Furthermore, this marker injects no arguments in the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call (this means that neither ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," nor ",Object(r.b)("inlineCode",{parentName:"p"},"null")," nor any other value, just treat them as if they were never inserted when it comes to understanding which arguments the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call will be made with)"),Object(r.b)("p",null,"As for the ",Object(r.b)("inlineCode",{parentName:"p"},"deps.withMeta")," marker, this marker returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Dep")," instance, which means you can call ",Object(r.b)("inlineCode",{parentName:"p"},".withMeta(meta)")," on it. Please note that the following invocations are equivalent"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.withAlwaysMeta(metaA).withMeta(metaB).withMeta(metaC)\ndeps.withAlwaysMeta({ ...{ ...metaA, ...metaB }, ...metaC })\n")),Object(r.b)("h3",{id:"depswithmetaonmount"},"deps.withMetaOnMount"),Object(r.b)("blockquote",null,Object(r.b)("p",{parentName:"blockquote"},"meta setting marker")),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.withMetaOnMount(meta): Dep\n")),Object(r.b)("p",null,"This marker allows to set metadata on a ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call just for the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call that happens at mount. The ",Object(r.b)("inlineCode",{parentName:"p"},"meta")," argument must be a plain javascript object. Furthermore, this marker injects no arguments in the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call (this means that neither ",Object(r.b)("inlineCode",{parentName:"p"},"undefined")," nor ",Object(r.b)("inlineCode",{parentName:"p"},"null")," nor any other value, just treat them as if they were never inserted when it comes to understanding which arguments the ",Object(r.b)("inlineCode",{parentName:"p"},"run")," call will be made with)"),Object(r.b)("p",null,"As for the ",Object(r.b)("inlineCode",{parentName:"p"},"deps.withMeta")," marker, this marker returns a ",Object(r.b)("inlineCode",{parentName:"p"},"Dep")," instance, which means you can call ",Object(r.b)("inlineCode",{parentName:"p"},".withMeta(meta")," on it. Please note that the following invocations are equivalent"),Object(r.b)("pre",null,Object(r.b)("code",{parentName:"pre",className:"language-js"},"deps.withMetaOnMount(metaA).withMeta(metaB).withMeta(metaC)\ndeps.withMetaOnMount({ ...{ ...metaA, ...metaB }, ...metaC })\n")),Object(r.b)("h3",{id:"multiple-meta-setting-markers-in-deps"},"Multiple meta setting markers in deps"),Object(r.b)("p",null,"You are free to use as many ",Object(r.b)("em",{parentName:"p"},"meta setting markers")," in your ",Object(r.b)("em",{parentName:"p"},"dependencies")," arrays, but remember that the engine will always squash them into a single object before starting the call. In case you have many ",Object(r.b)("em",{parentName:"p"},"meta setting markers"),", all of them will be evaluated and the results will be merged in array order, i.e. from left to right, as usual in ",Object(r.b)("em",{parentName:"p"},"rocketjump")))}s.isMDXComponent=!0},133:function(e,t,n){"use strict";n.d(t,"a",(function(){return b})),n.d(t,"b",(function(){return d}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function c(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=r.a.createContext({}),p=function(e){var t=r.a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):c(c({},t),e)),n},b=function(e){var t=p(e.components);return r.a.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},m=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=p(n),m=a,d=b["".concat(i,".").concat(m)]||b[m]||u[m]||o;return n?r.a.createElement(d,c(c({ref:t},s),{},{components:n})):r.a.createElement(d,c({ref:t},s))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var s=2;s<o;s++)i[s]=n[s];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);