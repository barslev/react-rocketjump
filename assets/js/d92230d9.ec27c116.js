(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{118:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return c})),n.d(t,"default",(function(){return u}));var a=n(3),i=n(7),o=(n(0),n(124)),r={id:"api_mutations",title:"Mutations",sidebar_label:"Extension: mutations",slug:"/api-mutations"},s={unversionedId:"api_mutations",id:"version-2.x/api_mutations",isDocsHomePage:!1,title:"Mutations",description:"Generalities",source:"@site/versioned_docs/version-2.x/api_mutations.md",slug:"/api-mutations",permalink:"/react-rocketjump/docs/api-mutations",editUrl:"https://github.com/inmagik/react-rocketjump/edit/master/website/versioned_docs/version-2.x/api_mutations.md",version:"2.x",sidebar_label:"Extension: mutations",sidebar:"version-2.x/someSidebar",previous:{title:"RocketJump Composition",permalink:"/react-rocketjump/docs/api-composition"},next:{title:"Connecting RJ Objects",permalink:"/react-rocketjump/docs/connect-generalities"}},c=[{value:"Generalities",id:"generalities",children:[]},{value:"Defining mutations",id:"defining-mutations",children:[{value:"effect",id:"effect",children:[]},{value:"updater",id:"updater",children:[]},{value:"effectCaller",id:"effectcaller",children:[]},{value:"takeEffect",id:"takeeffect",children:[]},{value:"reducer",id:"reducer",children:[]}]},{value:"Mutation wrappers",id:"mutation-wrappers",children:[{value:"Single mutation",id:"single-mutation",children:[]},{value:"Multiple mutation",id:"multiple-mutation",children:[]}]},{value:"Using the mutations state",id:"using-the-mutations-state",children:[]}],l={toc:c};function u(e){var t=e.components,n=Object(i.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},l,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("h2",{id:"generalities"},"Generalities"),Object(o.b)("p",null,"Mutations are a way to easily combine multiple side-effectful operation working on the same data. For instance, when we deal with a REST resource, it's highly recommended to keep the representation of your resource in a single state and to update it with mutations, that in turn map to HTTP verbs."),Object(o.b)("p",null,"There are solutions to problems of this kind even without mutations (for instance, a possible solution is ",Object(o.b)("a",{parentName:"p",href:"/react-rocketjump/docs/tips-n-tricks"},"this"),"), but using mutations allows you to better group conceptually related functionalities together, to keep your application state clean, and to use a declarative pattern."),Object(o.b)("p",null,"A mutation is essentially defined by two elements:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"the effect to run (",Object(o.b)("em",{parentName:"li"},"effect"),")"),Object(o.b)("li",{parentName:"ul"},"the logic to update the shared state given the result of the effect (",Object(o.b)("em",{parentName:"li"},"updater"),")")),Object(o.b)("p",null,"Then we can add some accessory elements:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"some logic used to invoke the effect (",Object(o.b)("em",{parentName:"li"},"effectCaller"),")"),Object(o.b)("li",{parentName:"ul"},"some logic used to keep a mutation state (for instance, to track when the effect is running) (",Object(o.b)("em",{parentName:"li"},"reducer"),")"),Object(o.b)("li",{parentName:"ul"},"some logic used to describe what to do when multiple runs of a mutation are asked by user (",Object(o.b)("em",{parentName:"li"},"takeEffect"),")")),Object(o.b)("p",null,"Given this, React RocketJump can create a full mutation workflow:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"For each mutation, a special RocketJump Action is created and injected in the action bag"),Object(o.b)("li",{parentName:"ol"},"Calling the injected action causes the ",Object(o.b)("em",{parentName:"li"},"effectCaller")," to be invoked"),Object(o.b)("li",{parentName:"ol"},"The ",Object(o.b)("em",{parentName:"li"},"effectCaller")," is in turn expected to invoke the ",Object(o.b)("em",{parentName:"li"},"effect")),Object(o.b)("li",{parentName:"ol"},"As long as the ",Object(o.b)("em",{parentName:"li"},"effect")," proceeds, some plain actions can be intercepted by the ",Object(o.b)("em",{parentName:"li"},"reducer"),", if defined"),Object(o.b)("li",{parentName:"ol"},"When the ",Object(o.b)("em",{parentName:"li"},"effect")," resolves successfully, the ",Object(o.b)("em",{parentName:"li"},"updater")," is called with the previous state and the ",Object(o.b)("em",{parentName:"li"},"effect")," result in order to compute the next state")),Object(o.b)("h2",{id:"defining-mutations"},"Defining mutations"),Object(o.b)("p",null,"Mutations can be defined for a RocketJump Object by adding a ",Object(o.b)("em",{parentName:"p"},"mutations")," configuration property as a sibling of the ",Object(o.b)("em",{parentName:"p"},"effect")," property. The ",Object(o.b)("em",{parentName:"p"},"mutations")," property contains an Object whose property names are mutation names, and the corresponding values are mutation descriptors, like this"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const SomeRjObject = rj({\n    effect: id => fetchPlayerById(id),\n    mutations: {\n        update: UpdateMutationDescriptor,\n        ban: BanMutationDescriptor,\n        reward: RewardMutationDescriptor,\n        ...\n    }\n})\n")),Object(o.b)("p",null,"A mutation descriptor is nothing more than a plain JavaScript object with some configuration in. In the following, we are going to describe all the available configuration options"),Object(o.b)("h3",{id:"effect"},"effect"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"(...args) => Promise | (...args) => Observable")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"effect")," configuration describes the side effect performed by the mutation: this can be any function you wish, provided that you return a ",Object(o.b)("inlineCode",{parentName:"p"},"Promise")," or an ",Object(o.b)("inlineCode",{parentName:"p"},"Observable")," provided by ",Object(o.b)("a",{parentName:"p",href:"https://rxjs-dev.firebaseapp.com/"},"rxJS"),". The rest is up to you."),Object(o.b)("p",null,"Parameters of the function you pass are in principle up to you: you are free to define them as you wish, but please note that some other configuration properties (like ",Object(o.b)("em",{parentName:"p"},"effectCaller"),") may influence the way parameters are passed to your function."),Object(o.b)("h3",{id:"updater"},"updater"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"string | (state: Object, effectResult: Object) => Object")),Object(o.b)("p",null,"The ",Object(o.b)("inlineCode",{parentName:"p"},"updater")," configuration property describes how to update the shared state given the result of a run of the mutation: each time the mutation completes, this function is called to reconcile the state. In order to write it properly, you must have a knowledge of the state shape. The default state shape in React RocketJump is"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"{\n    data: /* result of the last successful (main) effect run */,\n    error: /* error of the last rejected (main) effect run */,\n    pending: /* bool telling if the (main) effect is running */,\n}\n")),Object(o.b)("p",null,"where with ",Object(o.b)("em",{parentName:"p"},"main")," effect is the one defined in the configuration object, not that defined in the mutation. Anyway, remember that you can change it by setting a ",Object(o.b)("em",{parentName:"p"},"reducer")," property on your configuration, or by using some plugin, or again by extending some RocketJump Partials, ... Summing up, refer to the documentation of the options you are using to deduce to know the right state shape."),Object(o.b)("p",null,"The ",Object(o.b)("em",{parentName:"p"},"updater")," function must be ",Object(o.b)("em",{parentName:"p"},"pure"),": given the same params, it must produce the same result. No side effects here. Forget them."),Object(o.b)("p",null,"As a shortcut, you can also set the ",Object(o.b)("em",{parentName:"p"},"updater")," to the name of any action present in the action bag: the action will be invoked with the effect result as a parameter and will be delegated to update the state"),Object(o.b)("h3",{id:"effectcaller"},"effectCaller"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"type Effect = Function<Promise | Observable>\neffectCaller: false |\n              rj.configured() |\n              (effect: Effect, ...params: any[]) => Promise | Observable\n")),Object(o.b)("p",null,"This setting is used to hook into the process of launching the effect, and can be used to alter its params or to add some more of them. The first argument is the ",Object(o.b)("inlineCode",{parentName:"p"},"effect")," to be called, and the subsequent arguments are the arguments the user sent in the action associated to the mutation. You can do everything you need here, the important thing is that you call the effect and return the Promise used to await for task completion, or an Rx Observable (this is useful if you are using rxJS Ajax)."),Object(o.b)("p",null,"This is an optional setting:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"if you don't set it, the RocketJump Object ",Object(o.b)("inlineCode",{parentName:"li"},"effectCaller")," is used to invoke the effect (it is inherited)"),Object(o.b)("li",{parentName:"ul"},"if you set it to ",Object(o.b)("inlineCode",{parentName:"li"},"false"),", the default effect caller is used (simply, the effect is called with the given arguments)"),Object(o.b)("li",{parentName:"ul"},"if you set it to ",Object(o.b)("inlineCode",{parentName:"li"},"rj.configured()")," the ",Object(o.b)("inlineCode",{parentName:"li"},"effectCaller")," is taken from the nearest ",Object(o.b)("inlineCode",{parentName:"li"},"<ConfigureRj />")," component up in the tree"),Object(o.b)("li",{parentName:"ul"},"if you set it to a function, that function is used")),Object(o.b)("h3",{id:"takeeffect"},"takeEffect"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"string | [policy: string, ...arguments] | (observable: RxObservable, mapTo: action => RxObservable) => RxObservable")),Object(o.b)("p",null,"This setting is used to control what to do when more instances of a task are spawned concurrently. Its usage is identical to the omonimuos setting of the main RocketJump definition, so please refer to the description in the ",Object(o.b)("a",{parentName:"p",href:"/react-rocketjump/docs/api-rj#takeeffect"},"rj constructor section")),Object(o.b)("h3",{id:"reducer"},"reducer"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"(state: Object, action: Object) => Object")),Object(o.b)("p",null,"This setting can be used to give a mutation some state, for instance to track if it is running or not, or to read errors."),Object(o.b)("p",null,"Shaping the state here is up to you, there is no default state"),Object(o.b)("p",null,"The actions that this reducer is expected to recognize are:"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"INIT"),", dispatched when the state is mounted"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"RUN"),", dispatched when a run of the mutation is scheduled"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"PENDING"),", dispateched when a run of the mutation starts"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"SUCCESS"),", dispatched when a run of the mutation resolves"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"FAILURE"),", dispatched when a run of the mutation rejects with some error")),Object(o.b)("p",null,"Their shape is the following:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},'import { INIT, RUN, PENDING, SUCCESS, FAILURE } from "react-rocketjump"\n\n{\n  type: INIT\n}\n\n{\n  type: RUN,\n  payload: {\n    params,         // the params your side effect was invoked with\n  }\n  meta: {\n    params          // the params your side effect was invoked with\n  },\n}\n\n{\n  type: PENDING,\n  meta: {\n    params,         // the params your side effect was invoked with\n  },\n}\n\n{\n  type: SUCCESS,\n  meta: {\n    params,\n  },\n  payload: {\n    data,           // the result of your mutation side effect\n    params,         // the params your side effect was invoked with\n  }\n}\n\n{\n  type: FAILURE,\n  meta: {\n    params,         // the params your side effect was invoked with\n  },\n  payload           // the rejection value of your side effect\n}\n')),Object(o.b)("h2",{id:"mutation-wrappers"},"Mutation wrappers"),Object(o.b)("p",null,"React RocketJump provides some utilities to setup sensible defaults on ",Object(o.b)("em",{parentName:"p"},"takeEffect")," and ",Object(o.b)("em",{parentName:"p"},"reducer")," for the most common cases"),Object(o.b)("h3",{id:"single-mutation"},"Single mutation"),Object(o.b)("p",null,"This options set is thought for mutations that have no overlapping or concurrent runs. A common use case, for instance, is a form submission."),Object(o.b)("p",null,"This preset sets ",Object(o.b)("em",{parentName:"p"},"effectCaller")," to ",Object(o.b)("em",{parentName:"p"},"exhaust")," and configures the reducer to mantain a state with the following shape:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"{\n    pending: bool,  // is the mutation running?\n    error: any      // rejection value of last failing run\n}\n")),Object(o.b)("p",null,"You can apply it to a mutation like this"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const TodosStateRj = rj({\n  effect: () => fetch(`/user`).then(r => r.json()),\n  mutations: {\n    updateUserProfile: rj.mutation.single({\n      // takeEffect and reducer are injected for you\n      effect: newProfile => fetch(`/user`, {\n         method: 'PATCH',\n         body: newProfile,\n      }).then(r => r.json()),\n      updater: 'updateData',\n    })\n  },\n})\n")),Object(o.b)("h3",{id:"multiple-mutation"},"Multiple mutation"),Object(o.b)("p",null,"This option set is designed for mutations that have multiple concurrent runs. Furthermore, it applies a grouping logic: runs belonging to the same group cannot be parallel and only one run per group can be active at a time."),Object(o.b)("p",null,"The application of this preset requires the user to define a key derivation function, that is a function that computes a key from the params fed into the mutation call. Runs with the same key are inserted in the same group, with the logic stated above."),Object(o.b)("p",null,"This preset sets ",Object(o.b)("em",{parentName:"p"},"effectCaller")," to ",Object(o.b)("em",{parentName:"p"},"groupByExhaust"),", and the reducer is configured to mantain a state with the following shape:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-ts"},"{\n  pendings: {\n    [key]: true | undefined,\n  },\n  errors: {\n    [key]: any | undefined\n  }\n}\n")),Object(o.b)("p",null,"You can apply it to a mutation like this"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const TodosState = rj(\n  rjPlainList(),\n    {\n    mutations: {\n      toggleTodo: rj.mutation.multi(\n        todo => todo.id,     // Key derivation function\n        {\n          effect: todo => fetch(`/todos/${todo.id}`, {\n             method: 'PATCH',\n             body: { done: !todo.done }\n          }).then(r => r.json()),\n          updater: 'updateItem'\n        }\n      )\n    },\n    effect: () => fetch(`/todos`).then(r => r.json()),\n  }\n)\n")),Object(o.b)("h2",{id:"using-the-mutations-state"},"Using the mutations state"),Object(o.b)("blockquote",null,Object(o.b)("p",{parentName:"blockquote"},"Mutation state is defined only for mutations with a ",Object(o.b)("em",{parentName:"p"},"reducer")," configured\nIf you use rj.mutation.single or rj.mutation.multi a ",Object(o.b)("em",{parentName:"p"},"reducer")," is automatically provided, otherwise you need to define your own")),Object(o.b)("p",null,"When you configure mutations in the context of a RocketJump Object, any instance of it will have the state sliced in two parts"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},"a slice holds the main state (i.e. the state you would have had if you did not define mutations)"),Object(o.b)("li",{parentName:"ul"},"the other slice holds a state object for any defined mutation")),Object(o.b)("p",null,"Selectors have been put in place to deal with this situation"),Object(o.b)("ul",null,Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"getRoot")," extracts the main state from the (opaque) state object"),Object(o.b)("li",{parentName:"ul"},Object(o.b)("em",{parentName:"li"},"getMutation")," extracts the state of a mutation")),Object(o.b)("p",null,"You can use them like in these examples"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const [state, actions] = useRunRj(RjObject, (state, { getRoot, getData }) => ({\n  mainState: getData(getRoot(state)),\n}))\n")),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const [state, actions] = useRunRj(MaRjObject, (state, { getMutation }) => ({\n  pending: getMutation(state, 'mutationName.path.to.your.state.as.deep.as.you.want'),\n}))\n")),Object(o.b)("p",null,"Furthermore, you can refer to mutations' states in ",Object(o.b)("em",{parentName:"p"},"computed")," section using a special selector ",Object(o.b)("inlineCode",{parentName:"p"},"@mutation"),", like the following example:"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre",className:"language-js"},"const MaTodosState = rj({\n  mutations: {\n    updateUserProfile: rj.mutation.single({\n      effect: newProfile => fetch(`/user`, {\n         method: 'PATCH',\n         body: newProfile,\n      }).then(r => r.json()),\n      updater: 'updateData',\n    })\n  },\n  effect: () => fetch(`/user`).then(r => r.json()),\n  computed: {\n    // Select data from your root state\n    todos: 'getData',\n    // Select data from a mutation state (`updateUserProfile`) is the name of the mutation\n    // followed by the path, relative to mutations state root, of the data you want to extract\n    updatingProfile: '@mutation.updateUserProfile.pending',\n  },\n})\n")))}u.isMDXComponent=!0},124:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return d}));var a=n(0),i=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=i.a.createContext({}),u=function(e){var t=i.a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},p=function(e){var t=u(e.components);return i.a.createElement(l.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},m=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,r=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),p=u(n),m=a,d=p["".concat(r,".").concat(m)]||p[m]||b[m]||o;return n?i.a.createElement(d,s(s({ref:t},l),{},{components:n})):i.a.createElement(d,s({ref:t},l))}));function d(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var l=2;l<o;l++)r[l]=n[l];return i.a.createElement.apply(null,r)}return i.a.createElement.apply(null,n)}m.displayName="MDXCreateElement"}}]);